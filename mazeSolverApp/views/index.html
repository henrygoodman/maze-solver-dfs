<link rel="stylesheet" type="text/css" href="stylesheets/mazing.css">

<div id="maze_container"><!-- --></div>
<script src="javascripts/maze_builder.js"></script>
<script>
  width = 40;
  height = 20;
  let Maze = new MazeBuilder(width, height);
  Maze.display("maze_container");
  var entry = Maze.getEntryPos();
  var exit = Maze.getExitPos();

  var isVisited = new Array(2*width);

  for (var i = 0; i <= isVisited.length; i++) {
    isVisited[i] = new Array(2*height);
  }

  document.write(entry + "\n");
  document.write(exit);
  //printAllPaths(entry, exit);

  function getAdj(x,y) {
    var validMoves = [];
      for (off1 = -1; off1 <= 1; off1++) {
        for (off2 = -1; off2 <= 1; off2++) {
            if(off1 == 0 && off2 == 0 || ((2*width) <= x+off1 <= 0) || ((2*height) <= y+off2 <= 0)) { continue;}
          
            var state = Maze.getClassName(x+off1, y+off2);
            if (!state) {
                validMoves.push([x+off1, y+off2]);
            }
        }

        if(off1 == 0 && off2 == 0 || ((2*width) <= x+off1 <= 0) || ((2*height) <= y+off2 <= 0)) { continue;}
      }

    return validMoves;
  }

  function printAllPaths(s,d) {
    
    for(y=0; y<=2*height; y++) {
      for (x=0; x<=2*width; x++) {
        isVisited[x][y]="false";
      }
    }
    var pathList = [];
  
        // add source to path[]
    //pathList.push(s);
  
        // Call recursive utility
    //printAllPathsUtil(s, d, isVisited, pathList);
    return;
  }
 
// A recursive function to print
    // all paths from 'u' to 'd'.
    // isVisited[] keeps track of
    // vertices in current path.
    // localPathList<> stores actual
    // vertices in the current path
  function printAllPathsUtil(u,d,isVisited,localPathList) {
    console.log(u[0], u[1]);
    if (u == (d)) {
        document.write(localPathList+"<br>");
        // if match found then no need to
        // traverse more till depth
        return;
    }
  
        // Mark the current node
    isVisited[ u[0], u[1] ] = "true";
    return;
    // Recur for all the vertices
    // adjacent to current vertex
    for (adj in getAdj(u[0], u[1])) {
        if (adj && !(isVisited[adj] == "true")) {
            // store current node
            // in path[]
            localPathList.push(adj);
            printAllPathsUtil(adj, d,
            isVisited, localPathList);

            // remove current node
            // in path[]
            localPathList.splice(localPathList.indexOf
            (adj),1);
        }
    }
    // Mark the current node
     isVisited[u[0]][u[1]] = "false";
  }


</script>

<body></body>

